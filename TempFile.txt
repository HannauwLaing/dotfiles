/**
 * Run with this:
 *
 * javac ./*.java; java FunWallPaper
 *
 * a glitch happends when you comment the StdDraw.show() on line 103
 * on the 1st loop the graph is drawn by edges but after that it is drawn as a
 * hole
 */

import java.util.ArrayList;
//import java.util.LinkedList;
import java.awt.*;

public class FunWallPaper {
  public static int speed = 31;
  public static int swirlNum = 1;
  public static int density = 4;
  public static double scale = 1.1;

  // TODO take args as input and change values above
  // also add starting size 
  // validation that values is valid

  // if future me wants to make it a acutal wallpapper
  // sort as image and change to background to that image
  //
  // https://stackoverflow.com/questions/68755837/is-there-a-universal-way-to-set-a-wallpaper-on-linux


  public static void main(String[] args) {
    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
    int w  = (int)(screenSize.getWidth()*0.95);
    int h = (int)(screenSize.getHeight()*0.95);
    
    
    int screensize = 930;
    //StdDraw.setCanvasSize(screensize * 2, screensize);
    StdDraw.setCanvasSize(w, h);
    StdDraw.enableDoubleBuffering();
    for (int i = 10 + 50* density; i < 10000; i = (int)(i*scale)/2*2 ) { 
      speed = (int)(speed*scale);
      
      int width = i *1920/ 1080;
      int height = i ;
      String[] input = {width + "", height + "", (width * height) + ""};
      runner(input);
    }

  }
  public static void runner(String[] args) {

    Integer width = Integer.parseInt(args[0]);
    Integer height = Integer.parseInt(args[1]);
    StdDraw.setXscale(width / 10 - 6*width / 100, width / 10 * 9 + 13*width / 100/2);
    StdDraw.setYscale(height / 10 - 15*height / 100/2, height / 10 * 9 + 6*height / 100);
    StdDraw.clear();
    StdDraw.setPenColor(StdDraw.BLACK);
    StdDraw.filledSquare(0, 0, (width + height) * 2);

    makeAndDrawMaze(width, height);
    StdDraw.show(100);
  }
  public static void makeAndDrawMaze(Integer width, Integer height) {
    int start = (width * height) / 2 + width / 2 ;
    int ved = 5;
    int ied = 2;
    boolean[] marked = new boolean[width * height];

    //LinkedList<Integer> nextadjvertexs = new LinkedList<>();
    ArrayList<Integer> nextadjvertexs = new ArrayList<>();

    marked[start] = true;

    for (Integer nextvertex : getadjvertexIndex(start, marked, width, height)) {
      nextadjvertexs.add(nextvertex);
    }
    while (nextadjvertexs.size() > 0) {
      int nextindex = StdRandom.uniform(0, nextadjvertexs.size());
      int nextvertex = nextadjvertexs.get(nextindex);
      nextadjvertexs.remove(nextindex);
      ied++;
      if (marked[nextvertex]) {
        continue;
      }
      if ((ied * 100) / (ved) > 50) {
        
        for (int index = 0; index < nextadjvertexs.size(); index++) {
          if (marked[nextadjvertexs.get(index)]) {
            nextadjvertexs.remove(index);
          }
          ied = 2;
          ved = 5;
        }
        nextadjvertexs.trimToSize();
        
      }
      ied--;
      ved++;
      int[] nextver = getadjvertexIndex(nextvertex, marked, width, height);
      int nodex = 0;
      int nodey = 0;
      int adjx = 0;
      int adjy = 0;

      for (int adjtonext : nextver) {
        if (adjtonext == -1) {
          continue;
        }
        if (marked[adjtonext]) {
          if (marked[nextvertex]) {
            if (StdRandom.bernoulli()) {
              nodex = adjtonext % width;
              nodey = adjtonext / width;
              adjx = nextvertex % width;
              adjy = nextvertex / width;
            }
          } else {
            marked[nextvertex] = true;
            nodex = adjtonext % width;
            nodey = adjtonext / width;
            adjx = nextvertex % width;
            adjy = nextvertex / width;
          }
        } else {
          nextadjvertexs.add(adjtonext);
        }

      }
      double xdist = (width / 2 - adjx);
      double ydist = (height / 2 - adjy);

      /*
      int DistToCore = (int)Math.sqrt(xdist * xdist + ydist * ydist);
      xdist = (xdist == 0) ? 0.00001 : xdist;
      */

      double rpolar = Math.sqrt(xdist * xdist + ydist * ydist);
      double thetapolar = Math.atan(ydist / xdist) + (2*Math.PI);

      int DistToCore = (int)Math.abs((rpolar + 14.2*thetapolar*Math.PI)) * 11 * swirlNum;
      int[] colour = BetterGetColor(DistToCore);
      // 35 is 2 spirals
      // 70 is 4 spirals
      // 140 is 8? spirals
      // 280 is ??? spirals
      

      StdDraw.setPenColor(colour[0], colour[1], colour[2]);
      StdDraw.line(nodex, nodey, adjx, adjy);
      if (nextadjvertexs.size() % (1 + speed) == 0) {
        StdDraw.show();
        //StdDraw.show(1);
        
      } else {
        StdDraw.enableDoubleBuffering();

      }
    }
  }
  public static int[] getadjvertexIndex(int curvertex, boolean[] marked,
                                        Integer width, Integer height) {
    //  < v ^ >
    int[] adjv = {-1, -1, -1, -1};
    int nodex = curvertex % width;
    int nodey = curvertex / width;
    if (0 < nodex) {
      adjv[0] = curvertex - 1;
    }
    if (0 < nodey) {
      adjv[1] = nodex + (nodey - 1) * width;
    }
    if (nodey + 1 < height) {
      adjv[2] = nodex + (nodey + 1) * width;
    }
    if (nodex + 1 < width) {
      adjv[3] = curvertex + 1;
    }

    return adjv;
  }

public static int[] BetterGetColor(int ColorNum) {
    int maxcolval = 255;
    int mincolval = 1;
    int multiplier = 1;
    int difcol = (maxcolval - mincolval);
    int max = difcol * 6;
    int testnum = (ColorNum * multiplier) % max;
    
    int hillwidth = (int)((float)max/22*8);
    int offset = max/3;

    int belR  = GetValAH(testnum, offset*0, hillwidth) + 0*GetValAH(testnum, offset*6 , hillwidth);
    int belG  = GetValAH(testnum, offset*1, hillwidth);
    int belB  = GetValAH(testnum, offset*2, hillwidth);
    
    belR += GetValAH(testnum, offset*3 , hillwidth);
    belG += GetValAH(testnum, offset*4 , hillwidth);
    belB += GetValAH(testnum, offset*5 , hillwidth);
    
    
    belR = belR < 1 ? 1 : belR/2 +mincolval +0;
    belG = belG < 1 ? 1 : belG/2 +mincolval +0;
    belB = belB < 1 ? 1 : belB/2 +mincolval +0;

    belR = belR > mincolval ? (belR < 254 ? belR : maxcolval)  : mincolval;
    belG = belG > mincolval ? (belG < 254 ? belG : maxcolval)  : mincolval;
    belB = belB > mincolval ? (belB < 254 ? belB : maxcolval)  : mincolval;
    //System.out.println("test3:"+max+":\t"+belR+"\t"+belG+"\t"+belB+"\t");
    //belB = 0;
    //belG = 0;
  
    int[] newcol = {belR, belG, belB};
    return newcol;
  }
// GetValueAroundHill
  public static int GetValAH(int num, int hill, int width) {
    if (num < hill) {
      //uphill
      if (num - hill + width < 0) {
        //System.out.print("test2:"+num+":\t"+(hill-width)+"\t");
        return 1;
      } else {
        
        return num - hill + width;
      }
    } else {
      //downhill
      if (hill - num + width < 0) {
        return 1;
      } else {
        //if (true) {return 1;}
        return (hill - num + width);
      }
    }

  }
}
